#+title My Emacs config
;; #+PROPERTY: header-args:emacs-lisp :tangle ./init.el
#+PROPERTY: header-args:emacs-lisp :tangle yes

* My Emacs Config
** Basic Settings
*** lexical binding
#+begin_src emacs-lisp

  ;;; -*- lexical-binding: t; -*-

#+end_src
*** inhibit startup message
#+begin_src emacs-lisp

  (setq inhibit-startup-message t)

#+end_src
*** disable scrollbar, toolbar, tooltips, and menu bar
#+begin_src emacs-lisp

  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)

  (menu-bar-mode -1)

#+end_src
*** make space between edge and text
#+begin_src emacs-lisp

  (set-fringe-mode 10)

#+end_src
*** visual bell instead of beep
#+begin_src emacs-lisp

  (setq visible-bell t)

#+end_src
*** display line numbers in most modes
#+begin_src emacs-lisp

  (global-display-line-numbers-mode t)
  (column-number-mode)
  ;; disable line numbers for some modes
  (dolist (mode '(org-mode-hook
		  term-mode-hook
		  shell-mode-hook
		  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src
*** set scroll margins and how much to jump cursor when leaves visible bounds
#+begin_src emacs-lisp

  (setq scroll-margin 8)
  (setq hscroll-margin 8)
  (setq scroll-conservatively 1000)

#+end_src
** Prep Package manager
*** make sure we have melpa
#+begin_src emacs-lisp
  
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
			   ("org" . "https://orgmode.org/elpa/")
			   ("elpa" . "https://elpa.gnu.org/packages/")))
#+end_src
*** bootstrap use-package
#+begin_src emacs-lisp

  (package-initialize)

  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)

#+end_src
*** all packages should be ensured by default
#+begin_src emacs-lisp

  (setq use-package-always-ensure t)

#+end_src
** add theme
#+begin_src emacs-lisp

  (use-package doom-themes
    :init
    (load-theme 'doom-solarized-light t))

#+end_src
** Set Up Evil Mode
*** evil mode
#+begin_src emacs-lisp

    (use-package evil
      :init
      (setq evil-want-keybinding nil)
      (setq evil-want-integration t)
      (setq evil-want-C-i-jump nil)
      (setq evil-want-C-d-scroll nil)
      (setq evil-want-Y-yank-to-eol t)
      (setq evil-undo-system 'undo-redo)
      (setq evil-want-fine-undo t)
      :config
      (define-key evil-normal-state-map (kbd "C-.") nil)
      (define-key evil-normal-state-map (kbd "M-.") nil)
      (evil-mode 1))

#+end_src
*** also use evil collection
#+begin_src emacs-lisp

      (use-package evil-collection
	:after evil
	:config
	(evil-collection-init)
	(setq forge-add-default-bindings nil))

#+end_src
** allow recent files
#+begin_src emacs-lisp

  (recentf-mode 1) 

#+end_src

** nerd icons
*NOTE: The first time you load your configuration on a new machine, you'll need to run the following command interactively so that the mode like icons display correctly: M-x nerd-icons-install-fonts*
#+begin_src emacs-lisp

  (use-package nerd-icons)

#+end_src
** In Emacs Completion Framwork - Vertico
*** what is vertico?
Vertico is a minibuffer completion framework. So when you look for files, buffers, functions, or anything in the minibuffer it will give you suggestions.
*** vertico as recommended on the github
#+begin_src emacs-lisp

      (use-package vertico
	:init
	(vertico-mode)

	(setq vertico-scroll-margin 2)

	;; Show more candidates
	(setq vertico-count 20)

	;; Grow and shrink the Vertico minibuffer
	(setq vertico-resize t)

	;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
	(setq vertico-cycle t)
	(define-key vertico-map (kbd "C-j") nil)
	)

#+end_src
*** save history for completions when emacs restarts
Vertico sorts by history position
We also want to persist the kill ring and registers in emacs
TODO: make it so that bookmarks are in the keymap and they get saved automatically when created, not when emacs is closed to prevent losses of bookmarks
TODO: make it so that I can jump to a narrow list of files like harpoon
#+begin_src emacs-lisp

  (use-package savehist
    :init
    (savehist-mode)
    (setq savehist-additional-variables (append '(register-alist kill-ring) savehist-additional-variables)) 
    )

#+end_src
*** additional useful configurations according to vertico github
#+begin_src emacs-lisp

  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
		    (replace-regexp-in-string
		     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
		     crm-separator)
		    (car args))
	    (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
	  '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))

#+end_src
*** Consult
**** what is consult?
Consult provides better searching with things like grep, ripgrep, a better buffer switching interface, recent file/command history. It can help create shortcuts for narrowing
search results down to the desired candidates.
**** setup
Note: consult-fd is a faster version of consult-find, and consult-locate is the fastest of all. However,
consult-locate uses a database so it might not know about super new files. They are all for fuzzy finding files.
I use projectile for fuzzy finding project files at the moment, it seems to be quick because projectile indexes everything.
TODO: try the org agenda ones: https://github.com/minad/consult?tab=readme-ov-file#org-mode
We will rebind the default commands to the enhanced consult ones
#+begin_src emacs-lisp

  (use-package consult
    :bind
    (([remap switch-to-buffer] . consult-buffer)
     ([remap switch-to-buffer-other-window] . consult-buffer-other-window)
     ([remap switch-to-buffer-other-frame] . consult-buffer-other-frame)
     ([remap yank-pop] . consult-yank-pop)
     ([remap goto-line] . consult-goto-line)
     ([remap imenu] . consult-imenu)
     ([remap load-theme] . consult-theme)
     ([remap bookmark-jump] . consult-bookmark)
     ([remap locate] . consult-locate)
     ([remap recentf-open-files] . consult-recent-file)
     ([remap evil-show-marks] . consult-mark)
     ([remap man] . consult-man)
     ([remap evil-show-registers] . consult-register)
     ([remap Info-search] . consult-info)
     ;; new ones I infered from the github
     ([remap repeat-complex-command] . consult-complex-command)
     ([remap project-switch-to-buffer] . consult-project-buffer)
     ([remap isearch-edit-string] . consult-isearch-history)
     ([remap next-matching-history-element] . consult-history)
     ([remap previous-matching-history-element] . consult-history)
     )
    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
	  register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
	  xref-show-definitions-function #'consult-xref)

    :config

    ;; if which-key is installed this will trigger it to help
    (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; maybe don't even need to do this because I changed projectile to madify project.el itself anyway
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-function (lambda (_) (projectile-project-root)))
    )

#+end_src
*** Embark
**** what is embark?
Embark basically allows "right click" like contextual options. It can act on consult/vertico suggestions and gives you options to do something to what you are hovering.
**** setup
TODO: read more on the github to check for additional features
#+begin_src emacs-lisp
  (use-package embark
    :ensure t

    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("M-." . embark-dwim)        ;; runs default action on selection
     ("C-h B" . embark-bindings)
     )

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

#+end_src
*** marginalia
Enable rich annotations using the Marginalia package. Tip: M-x customize-variable in order to see all variables you can change from a particular package
#+begin_src emacs-lisp

  (use-package marginalia
    ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
    ;; available in the *Completions* buffer, add it to the
    ;; `completion-list-mode-map'.
    :bind (:map minibuffer-local-map
		("M-A" . marginalia-cycle))

    ;; The :init section is always executed.
    :init

    ;; Marginalia must be activated in the :init section of use-package such that
    ;; the mode gets enabled right away. Note that this forces loading the
    ;; package.
    (marginalia-mode))

#+end_src
*** add nerd icons to completions
#+begin_src emacs-lisp

  (use-package nerd-icons-completion
    :after marginalia
    :config
    (nerd-icons-completion-mode)
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

#+end_src
*** orderless for fuzzy completion
#+begin_src emacs-lisp

  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-consult-dispatch orderless-affix-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
	  completion-category-defaults nil
	  completion-category-overrides '((file (styles partial-completion)))))

#+end_src
*** Vertico Settings
**** enable tab expansion of prefix - disabled bc of orderless
Orderless completion doesn't support subtring completion unless you add substring completion before orderless
Thus I disabled this because I don't know how it would affect our results
#+begin_src emacs-lisp

  ;; (setq completion-styles '(substring orderless basic))
  ;; (keymap-set vertico-map "TAB" #'minibuffer-complete)

#+end_src
**** get completion help
#+begin_src emacs-lisp

  (keymap-set vertico-map "?" #'minibuffer-completion-help)

#+end_src
**** completion at point and region
Use `consult-completion-in-region' if Vertico is enabled.
Otherwise use the default `completion--in-region' function.
#+begin_src emacs-lisp

  (setq completion-in-region-function
	(lambda (&rest args)
	  (apply (if vertico-mode
		     #'consult-completion-in-region
		   #'completion--in-region)
		 args)))

#+end_src

**** clean up when shadowing paths
#+begin_src emacs-lisp

  (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)

#+end_src
**** make backspace delete directory
#+begin_src emacs-lisp

  (define-key vertico-map (kbd "DEL") #'vertico-directory-delete-char)

#+end_src
**** Change the bindings in vertico
#+begin_src emacs-lisp
  
  (keymap-set vertico-map "M-j" #'vertico-next)
  (keymap-set vertico-map "M-k" #'vertico-previous)

#+end_src
** modeline
#+begin_src emacs-lisp

  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 15)))

#+end_src
** rainbow delimiters
#+begin_src emacs-lisp

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

#+end_src
** which-key
#+begin_src emacs-lisp

  (use-package which-key
    :init (which-key-mode)
    :config
    (setq which-key-idle-delay 0.1))

#+end_src
** helpful
#+begin_src emacs-lisp

  (use-package helpful
    :bind
    ([remap describe-symbol] . helpful-symbol)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key))

#+end_src
** Transient states
*** hydra package
#+begin_src emacs-lisp

  (use-package hydra)

#+end_src
*** text scaling

#+begin_src emacs-lisp

  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

#+end_src
** projectile
#+begin_src emacs-lisp

  (use-package projectile
    :diminish projectile-mode
    :init
    (add-hook 'project-find-functions #'project-projectile)
    :config (projectile-mode)
    :custom (
	     (projectile-completion-system 'default)
	     (projectile-project-search-path '("~/code"))
	     (projectile-switch-project-action '(lambda () (call-interactively #'find-file)))
	     )
    )

#+end_src
** ediff
#+begin_src emacs-lisp

  (use-package ediff
    :custom
    (ediff-split-window-function 'split-window-horizontally)
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    )

#+end_src
** magit
#+begin_src emacs-lisp

  (use-package magit
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  (evil-collection-magit-setup)

#+end_src
** forge 
TODO: get this going
#+begin_src emacs-lisp

  (use-package forge
    :after magit
    :config
    (setq auth-sources '("~/.authinfo")))
  ;; https://magit.vc/manual/ghub/Storing-a-Token.html
#+end_src
** Org Mode
** make commenting easier
#+begin_src emacs-lisp

  (use-package evil-nerd-commenter
    :bind ("C-/" . evilnc-comment-or-uncomment-lines))

#+end_src
*** org
TODO: do this more
#+begin_src emacs-lisp

  (use-package org
    :config
    (setq org-ellipsis " ▾"
	  ;; org-hide-emphasis-markers t
	  )
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)
    (setq org-agenda-files '("~/.emacs.d/tasks.org"))
    )

#+end_src
*** org-bullets - change what the bullets look like at each level
#+begin_src emacs-lisp

  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src
*** make sure babel doesn't ask for permission to evaluate each time
#+begin_src emacs-lisp

  (require 'org-tempo)
  (setq org-confirm-babel-evaluate nil)

#+end_src
*** Add additional snippets to org-structure-template-alist
***** get rid of the defualt "example" template
#+begin_src emacs-lisp

  (setq org-structure-template-alist (delq (assoc "e" org-structure-template-alist) org-structure-template-alist))

#+end_src
***** add some additional languages to source code block snippets
#+begin_src emacs-lisp

  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))

#+end_src

** Literate Config Settings
Automatically tangle out our emacs.org config file when we save it:
Disabled because we tanlge this file on startup rather than on save now
#+begin_src emacs-lisp

  ;; (defun rune/org-babel-tangle-config ()
  ;;   (when (string-equal (buffer-file-name)
  ;; 		      (expand-file-name "~/.emacs.d/config.org"))

  ;;     (let ((org-confirm-babel-eval nil))
  ;;       (org-babel-tangle))))

  ;; (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'rune/org-babel-tangle-config)))


#+end_src
** LSP Related Config
*** increase garbage collection threshold for lsp-mode performance
#+begin_src emacs-lisp

  (setq gc-cons-threshold 100000000)

#+end_src
*** increase read-process memory for lsp-mode performance
Some of the language server responses are in 800k - 3M range
Here we are making it 1 mb
#+begin_src emacs-lisp

  (setq read-process-output-max (* 1024 1024))

#+end_src
*** Treesitter
This package seems to work much better than the built in emacs treesit
**** tree-sitter for highlighting
#+begin_src emacs-lisp

    (use-package tree-sitter-langs)

    (use-package tree-sitter
      :init

      (require 'tree-sitter)
      (require 'tree-sitter-hl)
      (require 'tree-sitter-langs)
      (require 'tree-sitter-debug)
      (require 'tree-sitter-query)

      (global-tree-sitter-mode 1)
      (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
      )



      #+end_src
**** tree-sitter objects
#+begin_src emacs-lisp

  ;; (use-package! evil-textobj-tree-sitter
  ;;   :when (modulep! :editor evil +everywhere)
  ;;   :defer t
  ;;   :init (after! tree-sitter (require 'evil-textobj-tree-sitter))
  ;;   :config
  ;;   (defvar +tree-sitter-inner-text-objects-map (make-sparse-keymap))
  ;;   (defvar +tree-sitter-outer-text-objects-map (make-sparse-keymap))
  ;;   (defvar +tree-sitter-goto-previous-map (make-sparse-keymap))
  ;;   (defvar +tree-sitter-goto-next-map (make-sparse-keymap))

  ;;   (evil-define-key '(visual operator) 'tree-sitter-mode
  ;;     "i" +tree-sitter-inner-text-objects-map
  ;;     "a" +tree-sitter-outer-text-objects-map)
  ;;   (evil-define-key 'normal 'tree-sitter-mode
  ;;     "[g" +tree-sitter-goto-previous-map
  ;;     "]g" +tree-sitter-goto-next-map)

  ;;   (map! (:map +tree-sitter-inner-text-objects-map
  ;; 	 "A" (+tree-sitter-get-textobj '("parameter.inner" "call.inner"))
  ;; 	 "f" (+tree-sitter-get-textobj "function.inner")
  ;; 	 "F" (+tree-sitter-get-textobj "call.inner")
  ;; 	 "C" (+tree-sitter-get-textobj "class.inner")
  ;; 	 "v" (+tree-sitter-get-textobj "conditional.inner")
  ;; 	 "l" (+tree-sitter-get-textobj "loop.inner"))
  ;; 	(:map +tree-sitter-outer-text-objects-map
  ;; 	 "A" (+tree-sitter-get-textobj '("parameter.outer" "call.outer"))
  ;; 	 "f" (+tree-sitter-get-textobj "function.outer")
  ;; 	 "F" (+tree-sitter-get-textobj "call.outer")
  ;; 	 "C" (+tree-sitter-get-textobj "class.outer")
  ;; 	 "c" (+tree-sitter-get-textobj "comment.outer")
  ;; 	 "v" (+tree-sitter-get-textobj "conditional.outer")
  ;; 	 "l" (+tree-sitter-get-textobj "loop.outer"))

  ;; 	(:map +tree-sitter-goto-previous-map
  ;; 	 "a" (+tree-sitter-goto-textobj "parameter.outer" t)
  ;; 	 "f" (+tree-sitter-goto-textobj "function.outer" t)
  ;; 	 "F" (+tree-sitter-goto-textobj "call.outer" t)
  ;; 	 "C" (+tree-sitter-goto-textobj "class.outer" t)
  ;; 	 "c" (+tree-sitter-goto-textobj "comment.outer" t)
  ;; 	 "v" (+tree-sitter-goto-textobj "conditional.outer" t)
  ;; 	 "l" (+tree-sitter-goto-textobj "loop.outer" t))
  ;; 	(:map +tree-sitter-goto-next-map
  ;; 	 "a" (+tree-sitter-goto-textobj "parameter.outer")
  ;; 	 "f" (+tree-sitter-goto-textobj "function.outer")
  ;; 	 "F" (+tree-sitter-goto-textobj "call.outer")
  ;; 	 "C" (+tree-sitter-goto-textobj "class.outer")
  ;; 	 "c" (+tree-sitter-goto-textobj "comment.outer")
  ;; 	 "v" (+tree-sitter-goto-textobj "conditional.outer")
  ;; 	 "l" (+tree-sitter-goto-textobj "loop.outer")))

  ;;   (after! which-key
  ;;     (setq which-key-allow-multiple-replacements t)
  ;;     (pushnew!
  ;;      which-key-replacement-alist
  ;;      '(("" . "\\`+?evil-textobj-tree-sitter-function--\\(.*\\)\\(?:.inner\\|.outer\\)") . (nil . "\\1")))))

#+end_src
**** set fontification level to maximum
4 may be too much
#+begin_src emacs-lisp

  ;; (setopt treesit-font-lock-level 4)

#+end_src
**** automatically install treesitter grammars
Built in treesitter doesn't seem to work well
#+begin_src emacs-lisp

  ;; (use-package treesit-auto
  ;;   :custom
  ;;   (treesit-auto-install t)
  ;;   :config
  ;;   (treesit-auto-add-to-auto-mode-alist 'all)
  ;;   (global-treesit-auto-mode))  

#+end_src
*** lsp-mode
#+begin_src emacs-lisp

    (use-package lsp-mode
      :init
      (setq lsp-modeline-diagnostics-enable t)
      (setq lsp-modeline-diagnostics-scope :workspace)
      (setq lsp-headerline-breadcrumb-mode t)
      :custom
      (lsp-auto-guess-root t)
      :config
      (lsp-enable-which-key-integration t)
      :commands lsp)

#+end_src
*** Integrate with consult
TODO: https://github.com/gagbo/consult-lsp
#+begin_src emacs-lisp

  ;; (use-package consult-lsp
  ;;   (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols))


#+end_src
*** lsp ui
Make the lsp interactions happen in a nice looking hovering box instead of minibuffer
#+begin_src emacs-lisp

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom (lsp-ui-doc-position 'at-point)
    )

#+end_src
*** dap-mode
Note: (use-package dap-LANGUAGE) to load the dap adapter for your language
#+begin_src emacs-lisp

  (use-package dap-mode)

#+end_src
*** Company Packages
***** company
Gives us nice completions inside of buffers like when writing code
#+begin_src emacs-lisp

  (use-package company
    ;; :after lsp-mode
    ;; :hook
    ;; (lsp-mode . company-mode)
    :init
    (global-company-mode) 
    :bind (:map company-active-map
		("<tab>" . company-complete-selection))
    (:map lsp-mode-map
	  ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))

#+end_src
***** company box
Make the company completion box look nicer
#+begin_src emacs-lisp

  (use-package company-box
    :hook (company-mode . company-box-mode))

#+end_src
*** TODO: Flycheck instead of flymake?
*** Language Specific Configurations
**** Python
***** set up pyright
#+begin_src emacs-lisp

    (use-package lsp-pyright
      ;; :ensure t
      ;; :hook (python-base-mode . (lambda ()
      ;; 				  (require 'lsp-pyright)
      ;; 				  (lsp-deferred)))
      )

#+end_src
***** venv support
If pyvenv-mode is on then we will be able to call pyvenv-activate
#+begin_src emacs-lisp

  (defun my/create-venv-in-project-dir ()
    "Look for a virtual environment named venv in project root directory. If one does not exist, create a venv in project directory. Then activate the virtual environment. This function also sets pyright's venv-dir and turns on lsp-deferred."
    (interactive)
    ;; If we already have a venv in a parent directory then we don't need to run this. This function will always run the first time a different python project is opened. Even if the venv exists, it will still need to run to activate it. Thus the lsp will get a chance to turn on
    (unless (and (boundp 'pyvenv-virtual-env) (file-exists-p pyvenv-virtual-env) (file-in-directory-p (file-name-directory pyvenv-virtual-env) default-directory))
      (let* (
	     (python-executable-path (or (executable-find "python3") (executable-find "python")))
	     (default-directory (projectile-project-root))
	     (venv-dir (expand-file-name (concat default-directory "venv/")))
	     )
	(if (eq python-executable-path nil)
	    (message "Could not find python executable")
	  (unless (file-directory-p venv-dir)
	    (with-current-buffer (get-buffer-create "*venv-output*")
	      (let ((exit-status (call-process python-executable-path nil t nil "-m" "venv" "venv")))
		(if (eq exit-status 0)
		    (message "Did not detect venv in project root, creating one now.")
		  (message "Error creating venv: %s" (buffer-string))))
	      (erase-buffer)
	      ))
	  (pyvenv-mode 1)
	  (pyvenv-activate venv-dir)
	  (require 'lsp-pyright)
	  (setq lsp-pyright-venv-path venv-dir)
	  (lsp-deferred)
	  (message "venv activated")
	  )
	)
      )
    )

  (use-package pyvenv
    :custom
    (pyvenv-mode-line-indicator '(pyvenv-virtual-env-name
				  ("[venv:" pyvenv-virtual-env-name "] ")))
    :hook
    (python-base-mode . my/create-venv-in-project-dir)
    )

#+end_src
**** Ocaml
***** tuareg
Tuareg: an Emacs OCaml mode
This archive contains files to help editing OCaml code, to highlight important parts of the code, to run an OCaml REPL (also called toplevel), and to run the OCaml debugger within Emacs.
TODO: (map! :localleader
:map tuareg-mode-map
"a" #'tuareg-find-alternate-file)
#+begin_src emacs-lisp

  (use-package tuareg
    :init
    :hook ('tuareg-mode-hook . 
			     (lambda()
			       ;; more idomatic comments
			       (setq-local comment-style 'multi-line)
			       (setq-local comment-continue "   ")
			       (tree-sitter)
			       (lsp-deferred)
			       ;; liagatures
			       (when (functionp 'prettify-symbols-mode)
				 (prettify-symbols-mode))))
    ;; Ocaml has quirky comments
    :bind (:map tuareg-mode-map ("C-/" . tuareg-comment-dwim))
    :config
    (setq tuareg-prettify-symbols-full t)
    (setq tuareg-opam-insinuate t)
    (tuareg-opam-update-env (tuareg-opam-current-compiler))
    )

#+end_src
***** merlin
Provides modern IDE features to editors
#+begin_src emacs-lisp
  (use-package merlin-company)
  (use-package merlin-iedit)

  (use-package merlin
    :config
    (push "<SHARE_DIR>/emacs/site-lisp" load-path) ; directory containing merlin.el
    (setq merlin-command "<BIN_DIR>/ocamlmerlin")  ; needed only if ocamlmerlin not already in your PATH
    (autoload 'merlin-mode "merlin" "Merlin mode" t)
    (add-hook 'tuareg-mode-hook #'merlin-mode)
    (add-hook 'caml-mode-hook #'merlin-mode)
    ;; Uncomment these lines if you want to enable integration with the corresponding packages
    (require 'merlin-iedit)       ; iedit.el editing of occurrences
    (require 'merlin-company)     ; company.el completion
    ;; (require 'merlin-ac)          ; auto-complete.el completion
    ;; To easily change opam switches and pick the ocamlmerlin binary accordingly,
    ;; you can use the minor mode https://github.com/ProofGeneral/opam-switch-mode
    :hook (tuareg-mode-local-vars . (lambda () (when (executable-find "ocamlmerlin") (merlin-mode))))
    )

#+end_src

** Custom keybindings
*** non leader key bound custom keymaps
#+begin_src emacs-lisp

  (evil-global-set-key 'motion (kbd "C-f") #'consult-line)
  (evil-global-set-key 'motion (kbd "C-s") #'save-buffer)

#+end_src
*** toggle keymap
#+begin_src emacs-lisp

  (defvar-keymap my/toggle-keymap)
  (which-key-add-keymap-based-replacements my/toggle-keymap
    "t" '("theme" . consult-theme)
    "s" '("text scale" . hydra-text-scale/body)
    "d" '("diff" . ediff))

#+end_src
*** insert keymap
#+begin_src emacs-lisp

  (defvar-keymap my/insert-keymap)
  (which-key-add-keymap-based-replacements my/insert-keymap
    "s" '("org source block" . org-insert-structure-template))

#+end_src
*** default leader keymap
*** edit keymap
#+begin_src emacs-lisp

  (defvar-keymap my/edit-keymap)
  (which-key-add-keymap-based-replacements my/edit-keymap
    "t" '("transpose words" . transpose-words))

#+end_src
*** error keymap
#+begin_src emacs-lisp

  (defvar-keymap my/error-keymap)
  (which-key-add-keymap-based-replacements my/error-keymap
    "/" '("search all" . consult-flymake)
    "c" '("compile error" . consult-compile-error))

#+end_src
*** rings and regs keymap
#+begin_src emacs-lisp
  
    (defvar-keymap my/rings-and-regs-keymap)
    (which-key-add-keymap-based-replacements my/rings-and-regs-keymap
      "k" '("kill ring" . consult-yank-from-kill-ring)
      "j" '("jump list" . evil-collection-consult-jump-list)
      "s" '("reg store" . consult-register-store)
      "r" '("registers" . consult-register)
      "m" '("macro" . consult-register)
      )

#+end_src
*** buffer keymap
#+begin_src emacs-lisp

  (defvar-keymap my/buffer-keymap)
  (which-key-add-keymap-based-replacements my/buffer-keymap
    "p" '("project buffer" . consult-project-buffer)
    "b" '("switch buffer" . switch-to-buffer)
    "k" '("kill buffer and window" . kill-buffer-and-window)
    "/" '("find in buffers" . consult-line-multi)
    "I" '("imenu" . consult-imenu-multi))

#+end_src
*** window keymap
#+begin_src emacs-lisp
  
  (defvar-keymap my/window-keymap)
  (which-key-add-keymap-based-replacements my/window-keymap
    "k" '("up" . evil-window-up)
    "j" '("down" . evil-window-down)
    "h" '("left" . evil-window-left)
    "l" '("right" . evil-window-right)
    "c" '("close" . evil-window-delete)
    "C" '("close others" . delete-other-windows))

#+end_src
*** project keymap
#+begin_src emacs-lisp

  (defvar-keymap my/project-keymap)
  (which-key-add-keymap-based-replacements my/project-keymap
    "/" '("all projects" . projectile-switch-project)
    "r" '("related file" . projectile-find-related-file))

#+end_src
*** file keymap
#+begin_src emacs-lisp

  (defun my/personal-config-dir ()
    "This function will get the directory that the user's init file is in"
    (interactive)
    (if-let (
	     (is-bound (boundp 'chemacs-profile))
	     (its-assoc (assoc 'user-emacs-directory chemacs-profile))
	     )
	(cdr its-assoc)
      (file-name-directory user-init-file)
      )
    )

  (defun my/open-personal-config-dir ()
    "This function will open the directory of the user's init file"
    (interactive)
    (let ((default-directory (concat (my/personal-config-dir) "/")))
      (call-interactively 'find-file)))

  (defvar-keymap my/file-keymap)
  (which-key-add-keymap-based-replacements my/file-keymap
    "p" '("personal config" . my/open-personal-config-dir)
    "r" '("recent files" . recentf-open-files)
    "/" '("search files" . projectile-find-file)
    "f" '("search uncached" . consult-fd))

#+end_src
*** code keymap
#+begin_src emacs-lisp

  (defvar-keymap my/code-keymap)
  (which-key-add-keymap-based-replacements my/code-keymap
    "d" '("definition" . xref-find-definitions))

#+end_src
*** leader keymap
#+begin_src emacs-lisp

  ;; Leader keybindings
  (defvar-keymap my/leader-keymap)
  (which-key-add-keymap-based-replacements my/leader-keymap
    "." '("find file" . find-file)
    "/" '("fuzzy search" . consult-ripgrep)
    "g" '("git" . magit)
    ":" '("mode only command" . consult-mode-command)
    "Q" '("quit emacs" . save-buffers-kill-terminal)
    "f" `("File" . ,my/file-keymap)
    "p" `("Project" . ,my/project-keymap)
    "w" `("Window" . ,my/window-keymap)
    "b" `("Buffer" . ,my/buffer-keymap)
    "r" `("Rings and Regs" . ,my/rings-and-regs-keymap)
    "e" `("Edit" . ,my/edit-keymap)
    "!" `("Error" . ,my/error-keymap)
    "i" `("Insert" . ,my/insert-keymap)
    "t" `("Toggle" . ,my/toggle-keymap)
    "c" `("Code" . ,my/code-keymap))

  (unbind-key "SPC" evil-motion-state-map)
  (bind-key "SPC" my/leader-keymap evil-motion-state-map)

#+end_src
*** custom lsp keymap
#+begin_src emacs-lisp

  (defun my/create-lsp-code-map ()
    (let ((my/lsp-code-keymap (define-keymap :parent my/code-keymap)))
      (when (bound-and-true-p lsp-mode)
	;; things that don't need additional conditions
	(which-key-add-keymap-based-replacements my/lsp-code-keymap
	  "p" '("describe at point" . lsp-describe-thing-at-point)
	  "a" '("code action" . lsp-execute-code-action)
	  "=" '("format buffer" . lsp-format-buffer)
	  "h" '("highlight" . lsp-document-highlight))

	(when (lsp-feature? "textDocument/definition")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "d" '("definition" . lsp-find-definition)))

	(when (lsp-feature? "textDocument/references")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "r" '("references" . lsp-find-references)))

	(when (lsp-feature? "textDocument/implementation")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "i" '("implementation" . lsp-find-implementation)))

	(when (lsp-feature? "textDocument/declaration")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "!" '("declaration" . lsp-find-declaration)))

	(when (lsp-feature? "textDocument/typeDefinition")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "t" '("type definition" . lsp-find-type-definition)))

	(when (or (lsp-can-execute-command? "java.navigate.resolveTypeHierarchy")
		  (and (functionp 'lsp-treemacs-type-hierarchy)
		       (lsp-feature? "textDocument/typeHierarchy")))
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "T" '("type hierarchy" . lsp-treemacs-type-hierarchy)))

	(when (and (functionp 'lsp-treemacs-call-hierarchy)
		   (lsp-feature? "textDocument/callHierarchy"))
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "c" '("call hierarchy" . lsp-treemacs-call-hierarchy)))

	(when (lsp-feature? "textDocument/rename")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "R" '("rename" . lsp-rename)))

	;; Session keybindings
	(let ((my/session-lsp-code-keymap (define-keymap)))
	  (which-key-add-keymap-based-replacements my/session-lsp-code-keymap
	    "l" '("logs" . lsp-workspace-logs-show)
	    "d" '("describe session" . lsp-describe-session)
	    "s" '("shutdown" . lsp-shutdown-workspace))
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap "S" `("Lsp Session" . ,my/session-lsp-code-keymap)))

	;; Workspace folders keybindings
	(let ((my/workspace-folders-lsp-code-keymap (define-keymap)))
	  (which-key-add-keymap-based-replacements my/workspace-folders-lsp-code-keymap
	    "a" '("add workspace folder" . lsp-workspace-folders-add)
	    "r" '("remove workspace folder" . lsp-workspace-folders-remove)
	    "o" '("open workspace folder" . lsp-workspace-folders-open))
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap "F" `("Lsp Workspace Folders" . ,my/workspace-folders-lsp-code-keymap)))

	;; Toggle lsp features keybindings
	(let ((my/toggle-lsp-features-code-keymap (define-keymap)))
	  (which-key-add-keymap-based-replacements my/toggle-lsp-features-code-keymap
	    "l" '("code lens" . lsp-lens-mode)
	    "h" '("breadcrumb" . lsp-headerline-breadcrumb-mode)
	    "a" '("modeline code actions" . lsp-modeline-code-actions-mode)
	    "d" '("modeline diagnostics" . lsp-modeline-diagnostics-mode))
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap "T" `("Lsp Toggle Features" . ,my/toggle-lsp-features-code-keymap)))

	my/lsp-code-keymap)))

    (add-hook 'lsp-after-open-hook
	      (lambda ()
		(evil-local-set-key 'motion (kbd "SPC c") (my/create-lsp-code-map))))

#+end_src

** auto close brackets
#+begin_src emacs-lisp

  (electric-pair-mode t)

#+end_src
