#+title My Emacs config
;; #+PROPERTY: header-args:emacs-lisp :tangle ./init.el
#+PROPERTY: header-args:emacs-lisp :tangle yes

* My Emacs Config
** Basic Settings
*** lexical binding
#+begin_src emacs-lisp

  ;;; -*- lexical-binding: t; -*-

#+end_src
*** inhibit startup message
#+begin_src emacs-lisp

  (setq inhibit-startup-message t)

#+end_src
*** disable scrollbar, toolbar, tooltips, and menu bar
#+begin_src emacs-lisp

  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)

  (menu-bar-mode -1)

#+end_src
*** make space between edge and text
#+begin_src emacs-lisp

  (set-fringe-mode 10)

#+end_src
*** visual bell instead of beep
#+begin_src emacs-lisp

  (setq visible-bell t)

#+end_src
*** display line numbers in most modes
#+begin_src emacs-lisp

  (global-display-line-numbers-mode t)
  (column-number-mode)
  ;; disable line numbers for some modes
  (dolist (mode '(org-mode-hook
		  term-mode-hook
		  shell-mode-hook
		  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src
*** set scroll margins and how much to jump cursor when leaves visible bounds
#+begin_src emacs-lisp

  (setq scroll-margin 8)
  (setq hscroll-margin 8)
  (setq scroll-conservatively 1000)

#+end_src
** Prep Package manager
*** make sure we have melpa
#+begin_src emacs-lisp
  
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
			   ("org" . "https://orgmode.org/elpa/")
			   ("elpa" . "https://elpa.gnu.org/packages/")))
#+end_src
*** bootstrap use-package
#+begin_src emacs-lisp

  (package-initialize)

  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)

#+end_src
*** all packages should be ensured by default
#+begin_src emacs-lisp

  (setq use-package-always-ensure t)

#+end_src
** add theme
#+begin_src emacs-lisp

  (use-package doom-themes
    :init
    (load-theme 'doom-solarized-light t))

#+end_src
** Set Up Evil Mode
*** evil mode
#+begin_src emacs-lisp

  (use-package evil
    :init
    (setq evil-want-keybinding nil)
    (setq evil-want-integration t)
    (setq evil-want-C-i-jump nil)
    (setq evil-want-C-d-scroll nil)
    (setq evil-want-Y-yank-to-eol t)
    (setq evil-undo-system 'undo-redo)
    (setq evil-want-fine-undo t)
    :config
    (define-key evil-normal-state-map (kbd "C-.") nil)
    (define-key evil-normal-state-map (kbd "M-.") nil)
    (evil-mode 1)

  (defun my/evil-dont-move-cursor-or-unhighlight-advice (orig-fun &rest args)
    "Stop evil mode from unhighlighting region or moving the cursor."
    (let ((orig-point (point))
	  (orig-mark (mark))
	  ;; note: calling (evil-visual-direction) actually doesn't give correct results so use the variable
	  (orig-direction evil-visual-direction))
      (apply orig-fun args)
      (if (eq evil-state 'visual)
	  (progn
	    (evil-visual-make-region (mark) (point))
	    (when (= orig-direction 1)
	      (exchange-point-and-mark)))
	(goto-char orig-point)
	(set-mark orig-mark))))

  (evil-define-operator my/evil-yank (beg end &optional type register yank-handler)
    "Basically applies the `my/evil-dont-move-cursor-or-unhighlight-advice` only to yank commands that were called directly. We don't want to advice the original evil-yank because it causes trouble with evil-visual-paste"
    :move-point nil
    :repeat nil
    (interactive "<R><x><y>")
    ;; Call the original evil-yank
    (my/evil-dont-move-cursor-or-unhighlight-advice 'evil-yank beg end type register yank-handler))

  (define-key evil-motion-state-map (kbd "y") nil)
  (define-key evil-normal-state-map (kbd "y") nil)
  (define-key evil-motion-state-map (kbd "y") 'my/evil-yank)

  (advice-add 'evil-indent :around #'my/evil-dont-move-cursor-or-unhighlight-advice)
)

#+end_src
*** also use evil collection
#+begin_src emacs-lisp

      (use-package evil-collection
	:after evil
	:config
	(evil-collection-init)
	(setq forge-add-default-bindings nil))

#+end_src
** allow recent files
#+begin_src emacs-lisp

  (recentf-mode 1) 

#+end_src

** nerd icons
*NOTE: The first time you load your configuration on a new machine, you'll need to run the following command interactively so that the mode like icons display correctly: M-x nerd-icons-install-fonts*
#+begin_src emacs-lisp

  (use-package nerd-icons)

#+end_src
** In Emacs Completion Framwork - Vertico
*** what is vertico?
Vertico is a minibuffer completion framework. So when you look for files, buffers, functions, or anything in the minibuffer it will give you suggestions.
*** vertico as recommended on the github
#+begin_src emacs-lisp

      (use-package vertico
	:init
	(vertico-mode)

	(setq vertico-scroll-margin 2)

	;; Show more candidates
	(setq vertico-count 20)

	;; Grow and shrink the Vertico minibuffer
	(setq vertico-resize t)

	;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
	(setq vertico-cycle t)
	(define-key vertico-map (kbd "C-j") nil)
	)

#+end_src
*** save history for completions when emacs restarts
Vertico sorts by history position
We also want to persist the kill ring and registers in emacs
TODO: make it so that I can jump to a narrow list of files like harpoon
#+begin_src emacs-lisp

  (use-package savehist
    :init
    (savehist-mode)
    (setq savehist-additional-variables (append '(register-alist kill-ring) savehist-additional-variables)) 
    )

#+end_src
*** additional useful configurations according to vertico github
#+begin_src emacs-lisp

  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
		    (replace-regexp-in-string
		     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
		     crm-separator)
		    (car args))
	    (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
	  '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))

#+end_src
*** Consult
**** what is consult?
Consult provides better searching with things like grep, ripgrep, a better buffer switching interface, recent file/command history. It can help create shortcuts for narrowing
search results down to the desired candidates.
**** setup
Note: consult-fd is a faster version of consult-find, and consult-locate is the fastest of all. However,
consult-locate uses a database so it might not know about super new files. They are all for fuzzy finding files.
I use projectile for fuzzy finding project files at the moment, it seems to be quick because projectile indexes everything.
TODO: try the org agenda ones: https://github.com/minad/consult?tab=readme-ov-file#org-mode
We will rebind the default commands to the enhanced consult ones
#+begin_src emacs-lisp

  (use-package consult
    :bind
    (([remap switch-to-buffer] . consult-buffer)
     ([remap switch-to-buffer-other-window] . consult-buffer-other-window)
     ([remap switch-to-buffer-other-frame] . consult-buffer-other-frame)
     ([remap yank-pop] . consult-yank-pop)
     ([remap goto-line] . consult-goto-line)
     ([remap imenu] . consult-imenu)
     ([remap load-theme] . consult-theme)
     ([remap bookmark-jump] . consult-bookmark)
     ([remap locate] . consult-locate)
     ([remap recentf-open-files] . consult-recent-file)
     ([remap evil-show-marks] . consult-mark)
     ([remap man] . consult-man)
     ([remap evil-show-registers] . consult-register)
     ([remap Info-search] . consult-info)
     ;; new ones I infered from the github
     ([remap repeat-complex-command] . consult-complex-command)
     ([remap project-switch-to-buffer] . consult-project-buffer)
     ([remap isearch-edit-string] . consult-isearch-history)
     ([remap next-matching-history-element] . consult-history)
     ([remap previous-matching-history-element] . consult-history)
     )
    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
	  register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
	  xref-show-definitions-function #'consult-xref)

    :config

    ;; if which-key is installed this will trigger it to help
    (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; maybe don't even need to do this because I changed projectile to madify project.el itself anyway
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-function (lambda (_) (projectile-project-root)))
    )

#+end_src
*** Embark
**** what is embark?
Embark basically allows "right click" like contextual options. It can act on consult/vertico suggestions and gives you options to do something to what you are hovering.
It also allows you to pick the thing to act on before choosing the action.
**** setup
#+begin_src emacs-lisp
  (use-package embark
    :bind
    ("C-." . embark-act)         ;; pick some comfortable binding
    ("M-." . embark-dwim)        ;; runs default action on selection
    ("C-h B" . embark-bindings)
    (:map embark-general-map ("y" . embark-copy-as-kill)) ;; default is on w, we don't remove that only add to it

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

#+end_src
*** marginalia
Enable rich annotations using the Marginalia package. Tip: M-x customize-variable in order to see all variables you can change from a particular package
#+begin_src emacs-lisp

  (use-package marginalia
    ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
    ;; available in the *Completions* buffer, add it to the
    ;; `completion-list-mode-map'.
    :bind (:map minibuffer-local-map
		("M-A" . marginalia-cycle))

    ;; The :init section is always executed.
    :init

    ;; Marginalia must be activated in the :init section of use-package such that
    ;; the mode gets enabled right away. Note that this forces loading the
    ;; package.
    (marginalia-mode))

#+end_src
*** add nerd icons to completions
#+begin_src emacs-lisp

  (use-package nerd-icons-completion
    :after marginalia
    :config
    (nerd-icons-completion-mode)
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

#+end_src
*** orderless for fuzzy completion
#+begin_src emacs-lisp

  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-consult-dispatch orderless-affix-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
	  completion-category-defaults nil
	  completion-category-overrides '((file (styles partial-completion)))))

#+end_src
*** Vertico Settings
**** enable tab expansion of prefix - disabled bc of orderless
Orderless completion doesn't support subtring completion unless you add substring completion before orderless
Thus I disabled this because I don't know how it would affect our results
#+begin_src emacs-lisp

  ;; (setq completion-styles '(substring orderless basic))
  ;; (keymap-set vertico-map "TAB" #'minibuffer-complete)

#+end_src
**** get completion help
#+begin_src emacs-lisp

  (keymap-set vertico-map "?" #'minibuffer-completion-help)

#+end_src
**** completion at point and region
Use `consult-completion-in-region' if Vertico is enabled.
Otherwise use the default `completion--in-region' function.
#+begin_src emacs-lisp

  (setq completion-in-region-function
	(lambda (&rest args)
	  (apply (if vertico-mode
		     #'consult-completion-in-region
		   #'completion--in-region)
		 args)))

#+end_src

**** clean up when shadowing paths
#+begin_src emacs-lisp

  (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)

#+end_src
**** make backspace delete directory
#+begin_src emacs-lisp

  (define-key vertico-map (kbd "DEL") #'vertico-directory-delete-char)

#+end_src
**** Change the bindings in vertico
#+begin_src emacs-lisp
  
  (keymap-set vertico-map "M-j" #'vertico-next)
  (keymap-set vertico-map "M-k" #'vertico-previous)

#+end_src
** modeline
#+begin_src emacs-lisp

  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 15)))

#+end_src
** rainbow delimiters
#+begin_src emacs-lisp

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

#+end_src
** which-key
#+begin_src emacs-lisp

  (use-package which-key
    :init (which-key-mode)
    :custom
    which-key-show-transient-maps t
    :config
    (setq which-key-idle-delay 0.1))

#+end_src
** helpful
#+begin_src emacs-lisp

  (use-package helpful
    :bind
    ([remap describe-symbol] . helpful-symbol)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key))

#+end_src
** Transient states
*** hydra package
#+begin_src emacs-lisp

  (use-package hydra)

#+end_src
*** text scaling

#+begin_src emacs-lisp

  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

#+end_src
** pdf viewing
#+begin_src emacs-lisp

  (setq doc-view-continuous t)

#+end_src
** projectile
#+begin_src emacs-lisp

  (use-package projectile
    :diminish projectile-mode
    :init
    (add-hook 'project-find-functions #'project-projectile)
    :config (projectile-mode)
    :custom (
	     (projectile-completion-system 'default)
	     (projectile-project-search-path '("~/code"))
	     (projectile-switch-project-action '(lambda () (call-interactively #'find-file)))
	     )
    )

#+end_src
** ediff
#+begin_src emacs-lisp

  (use-package ediff
    :custom
    (ediff-split-window-function 'split-window-horizontally)
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    )

#+end_src
** magit
#+begin_src emacs-lisp

  (use-package magit
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  (evil-collection-magit-setup)

#+end_src
** forge 
TODO: get this going
#+begin_src emacs-lisp

  (use-package forge
    :after magit
    :config
    (setq auth-sources '("~/.authinfo")))
  ;; https://magit.vc/manual/ghub/Storing-a-Token.html
#+end_src
** Terminals
*** vterm
;; TODO: set this up: https://github.com/akermu/emacs-libvterm?tab=readme-ov-file
#+begin_src emacs-lisp

  (use-package vterm)

#+end_src
** Org Mode
** make commenting easier
#+begin_src emacs-lisp

  (use-package evil-nerd-commenter
    :bind ("C-/" . evilnc-comment-or-uncomment-lines))

#+end_src
*** org
TODO: do this more
#+begin_src emacs-lisp

  (use-package org
    :config
    (setq org-ellipsis " ‚ñæ"
	  ;; org-hide-emphasis-markers t
	  )
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)
    (setq org-agenda-files '("~/.emacs.d/tasks.org"))
    )

#+end_src
*** org-bullets - change what the bullets look like at each level
#+begin_src emacs-lisp

  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("‚óâ" "‚óã" "‚óè" "‚óã" "‚óè" "‚óã" "‚óè")))

#+end_src
*** make sure babel doesn't ask for permission to evaluate each time
#+begin_src emacs-lisp

  (require 'org-tempo)
  (setq org-confirm-babel-evaluate nil)

#+end_src
*** Add additional snippets to org-structure-template-alist
***** get rid of the defualt "example" template
#+begin_src emacs-lisp

  (setq org-structure-template-alist (delq (assoc "e" org-structure-template-alist) org-structure-template-alist))

#+end_src
***** add some additional languages to source code block snippets
#+begin_src emacs-lisp

  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))

#+end_src

** Literate Config Settings
Automatically tangle out our emacs.org config file when we save it:
Disabled because we tanlge this file on startup rather than on save now
#+begin_src emacs-lisp

  ;; (defun rune/org-babel-tangle-config ()
  ;;   (when (string-equal (buffer-file-name)
  ;; 		      (expand-file-name "~/.emacs.d/config.org"))

  ;;     (let ((org-confirm-babel-eval nil))
  ;;       (org-babel-tangle))))

  ;; (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'rune/org-babel-tangle-config)))


#+end_src
** LSP Related Config
*** increase garbage collection threshold for lsp-mode performance
#+begin_src emacs-lisp

  (setq gc-cons-threshold 100000000)

#+end_src
*** increase read-process memory for lsp-mode performance
Some of the language server responses are in 800k - 3M range
Here we are making it 1 mb
#+begin_src emacs-lisp

  (setq read-process-output-max (* 1024 1024))

#+end_src
*** Treesitter
This package seems to work much better than the built in emacs treesit
**** tree-sitter for highlighting
#+begin_src emacs-lisp

    (use-package tree-sitter-langs)

    (use-package tree-sitter
      :init

      (require 'tree-sitter)
      (require 'tree-sitter-hl)
      (require 'tree-sitter-langs)
      (require 'tree-sitter-debug)
      (require 'tree-sitter-query)

      (global-tree-sitter-mode 1)
      (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
      )



      #+end_src
**** tree-sitter objects
#+begin_src emacs-lisp

  ;; (use-package! evil-textobj-tree-sitter
  ;;   :when (modulep! :editor evil +everywhere)
  ;;   :defer t
  ;;   :init (after! tree-sitter (require 'evil-textobj-tree-sitter))
  ;;   :config
  ;;   (defvar +tree-sitter-inner-text-objects-map (make-sparse-keymap))
  ;;   (defvar +tree-sitter-outer-text-objects-map (make-sparse-keymap))
  ;;   (defvar +tree-sitter-goto-previous-map (make-sparse-keymap))
  ;;   (defvar +tree-sitter-goto-next-map (make-sparse-keymap))

  ;;   (evil-define-key '(visual operator) 'tree-sitter-mode
  ;;     "i" +tree-sitter-inner-text-objects-map
  ;;     "a" +tree-sitter-outer-text-objects-map)
  ;;   (evil-define-key 'normal 'tree-sitter-mode
  ;;     "[g" +tree-sitter-goto-previous-map
  ;;     "]g" +tree-sitter-goto-next-map)

  ;;   (map! (:map +tree-sitter-inner-text-objects-map
  ;; 	 "A" (+tree-sitter-get-textobj '("parameter.inner" "call.inner"))
  ;; 	 "f" (+tree-sitter-get-textobj "function.inner")
  ;; 	 "F" (+tree-sitter-get-textobj "call.inner")
  ;; 	 "C" (+tree-sitter-get-textobj "class.inner")
  ;; 	 "v" (+tree-sitter-get-textobj "conditional.inner")
  ;; 	 "l" (+tree-sitter-get-textobj "loop.inner"))
  ;; 	(:map +tree-sitter-outer-text-objects-map
  ;; 	 "A" (+tree-sitter-get-textobj '("parameter.outer" "call.outer"))
  ;; 	 "f" (+tree-sitter-get-textobj "function.outer")
  ;; 	 "F" (+tree-sitter-get-textobj "call.outer")
  ;; 	 "C" (+tree-sitter-get-textobj "class.outer")
  ;; 	 "c" (+tree-sitter-get-textobj "comment.outer")
  ;; 	 "v" (+tree-sitter-get-textobj "conditional.outer")
  ;; 	 "l" (+tree-sitter-get-textobj "loop.outer"))

  ;; 	(:map +tree-sitter-goto-previous-map
  ;; 	 "a" (+tree-sitter-goto-textobj "parameter.outer" t)
  ;; 	 "f" (+tree-sitter-goto-textobj "function.outer" t)
  ;; 	 "F" (+tree-sitter-goto-textobj "call.outer" t)
  ;; 	 "C" (+tree-sitter-goto-textobj "class.outer" t)
  ;; 	 "c" (+tree-sitter-goto-textobj "comment.outer" t)
  ;; 	 "v" (+tree-sitter-goto-textobj "conditional.outer" t)
  ;; 	 "l" (+tree-sitter-goto-textobj "loop.outer" t))
  ;; 	(:map +tree-sitter-goto-next-map
  ;; 	 "a" (+tree-sitter-goto-textobj "parameter.outer")
  ;; 	 "f" (+tree-sitter-goto-textobj "function.outer")
  ;; 	 "F" (+tree-sitter-goto-textobj "call.outer")
  ;; 	 "C" (+tree-sitter-goto-textobj "class.outer")
  ;; 	 "c" (+tree-sitter-goto-textobj "comment.outer")
  ;; 	 "v" (+tree-sitter-goto-textobj "conditional.outer")
  ;; 	 "l" (+tree-sitter-goto-textobj "loop.outer")))

  ;;   (after! which-key
  ;;     (setq which-key-allow-multiple-replacements t)
  ;;     (pushnew!
  ;;      which-key-replacement-alist
  ;;      '(("" . "\\`+?evil-textobj-tree-sitter-function--\\(.*\\)\\(?:.inner\\|.outer\\)") . (nil . "\\1")))))

#+end_src
**** set fontification level to maximum
4 may be too much
#+begin_src emacs-lisp

  ;; (setopt treesit-font-lock-level 4)

#+end_src
**** automatically install treesitter grammars
Built in treesitter doesn't seem to work well
#+begin_src emacs-lisp

  ;; (use-package treesit-auto
  ;;   :custom
  ;;   (treesit-auto-install t)
  ;;   :config
  ;;   (treesit-auto-add-to-auto-mode-alist 'all)
  ;;   (global-treesit-auto-mode))  

#+end_src
*** lsp-mode
#+begin_src emacs-lisp

  (use-package lsp-mode
    :init
    (setq lsp-modeline-diagnostics-enable t)
    (setq lsp-modeline-diagnostics-scope :workspace)
    (setq lsp-headerline-breadcrumb-mode t)
    :custom
    (lsp-auto-guess-root t)
    (lsp-file-watch-threshold nil)
    :config
    (lsp-enable-which-key-integration t)
    :commands lsp)

#+end_src
*** integrate with consult
TODO: https://github.com/gagbo/consult-lsp
#+begin_src emacs-lisp

  ;; (use-package consult-lsp
  ;;   (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols))


#+end_src
*** lsp ui
Make the lsp interactions happen in a nice looking hovering box instead of minibuffer
#+begin_src emacs-lisp

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom (lsp-ui-doc-position 'at-point)
    )

#+end_src
*** dap-mode
Note: (use-package dap-LANGUAGE) to load the dap adapter for your language
#+begin_src emacs-lisp

  (use-package dap-mode)

#+end_src
*** Company Packages
***** company
Gives us nice completions inside of buffers like when writing code
#+begin_src emacs-lisp

  (use-package company
    ;; :after lsp-mode
    ;; :hook
    ;; (lsp-mode . company-mode)
    :init
    (global-company-mode) 
    :bind (:map company-active-map
		("<tab>" . company-complete-selection))
    (:map lsp-mode-map
	  ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))

#+end_src
***** company box
Make the company completion box look nicer
#+begin_src emacs-lisp

  (use-package company-box
    :hook (company-mode . company-box-mode))

#+end_src
*** Language Specific Configurations
**** Python
***** set up pyright
#+begin_src emacs-lisp

  (use-package lsp-pyright
    :init
    (setq lsp-pyright-multi-root nil)
    ;; :ensure t
    ;; :hook (python-base-mode . (lambda ()
    ;; 				  (require 'lsp-pyright)
    ;; 				  (lsp-deferred)))
    )

#+end_src
***** venv support
If pyvenv-mode is on then we will be able to call pyvenv-activate
Note that the pyright venv path may look wrong if you look at its value after
starting a second python lsp-mode session and looking at its value in the original session.
It may seem that you can only have one venv at a time but this isn't true. The variable
=lsp-pyright-venv-path= only matters at the lsp's start up. So if pyright starts with
this variable set to the correct thing it no longer matters what you change this variable to
because the lsp session only looks at that at startup.
#+begin_src emacs-lisp

  (defun my/create-venv-in-project-dir ()
    "Look for a virtual environment named venv in project root directory. If one does not exist, create a venv in project directory. Then activate the virtual environment. This function also sets pyright's venv-dir and turns on lsp-deferred."
    (interactive)
    ;; If we already have a venv in a parent directory then we don't need to run this. This function will always run the first time a different python project is opened. Even if the venv exists, it will still need to run to activate it. Thus the lsp will get a chance to turn on
    (unless (and (boundp 'pyvenv-virtual-env) (file-exists-p pyvenv-virtual-env) (file-in-directory-p (file-name-directory pyvenv-virtual-env) default-directory))
      (let* (
	     (python-executable-path (or (executable-find "python3") (executable-find "python")))
	     (default-directory (projectile-project-root))
	     (venv-dir (expand-file-name (concat default-directory "venv/")))
	     )
	(if (eq python-executable-path nil)
	    (message "Could not find python executable")
	  (unless (file-directory-p venv-dir)
	    (with-current-buffer (get-buffer-create "*venv-output*")
	      (let ((exit-status (call-process python-executable-path nil t nil "-m" "venv" "venv")))
		(if (eq exit-status 0)
		    (message "Did not detect venv in project root, creating one now.")
		  (message "Error creating venv: %s" (buffer-string))))
	      (erase-buffer)
	      ))
	  (pyvenv-mode 1)
	  (pyvenv-tracking-mode 1)
	  (set (make-local-variable 'pyvenv-activate) venv-dir)
	  (pyvenv-activate venv-dir)
	  (setq lsp-pyright-venv-path venv-dir)
	  (require 'lsp-pyright)
	  (lsp-deferred)
	  (message "venv activated")
	  )
	)
      )
    )

  (use-package pyvenv
    :custom
    (pyvenv-mode-line-indicator '(pyvenv-virtual-env-name
				  ("[venv:" pyvenv-virtual-env-name "] ")))
    :hook
    (python-base-mode . my/create-venv-in-project-dir)
    )

#+end_src
**** Ocaml
***** tuareg
Tuareg: an Emacs OCaml mode
This archive contains files to help editing OCaml code, to highlight important parts of the code, to run an OCaml REPL (also called toplevel), and to run the OCaml debugger within Emacs.
#+begin_src emacs-lisp

  (use-package tuareg
    :init
    :hook (tuareg-mode . 
			     (lambda()
			       ;; more idomatic comments
			       (setq-local comment-style 'multi-line)
			       (setq-local comment-continue "   ")
			       (lsp-deferred)
			       ;; liagatures
			       (when (functionp 'prettify-symbols-mode)
				 (prettify-symbols-mode))))
    ;; Ocaml has quirky comments
    :bind (:map tuareg-mode-map ("C-/" . tuareg-comment-dwim))
    :config
    (setq tuareg-prettify-symbols-full t)
    (setq tuareg-opam-insinuate t)
    (tuareg-opam-update-env (tuareg-opam-current-compiler))
    )

#+end_src
***** merlin
merlin is used by ocaml-lsp in the background so you definately don't want both interfering with each other
#+begin_src emacs-lisp
  ;; (use-package merlin-company)
  ;; (use-package merlin-iedit)

  ;; (use-package merlin
    ;; :config
    ;; (push "<SHARE_DIR>/emacs/site-lisp" load-path) ; directory containing merlin.el
    ;; (setq merlin-command "<BIN_DIR>/ocamlmerlin")  ; needed only if ocamlmerlin not already in your PATH
    ;; (autoload 'merlin-mode "merlin" "Merlin mode" t)
    ;; (add-hook 'tuareg-mode-hook #'merlin-mode)
    ;; (add-hook 'caml-mode-hook #'merlin-mode)
    ;; Uncomment these lines if you want to enable integration with the corresponding packages
    ;; (require 'merlin-iedit)       ; iedit.el editing of occurrences
    ;; (require 'merlin-company)     ; company.el completion
    ;; (require 'merlin-ac)          ; auto-complete.el completion
    ;; To easily change opam switches and pick the ocamlmerlin binary accordingly,
    ;; you can use the minor mode https://github.com/ProofGeneral/opam-switch-mode

    ;; merlin from opam to add this if I use emacs
    ;; (let ((opam-share (ignore-errors (car (process-lines "opam" "var" "share")))))
    ;;   (when (and opam-share (file-directory-p opam-share))
    ;;     ;; Register Merlin
    ;;     (add-to-list 'load-path (expand-file-name "emacs/site-lisp" opam-share))
    ;;     (autoload 'merlin-mode "merlin" nil t nil)
    ;;     ;; Automatically start it in OCaml buffers
    ;;     (add-hook 'tuareg-mode-hook 'merlin-mode t)
    ;;     (add-hook 'caml-mode-hook 'merlin-mode t)
    ;;     ;; Use opam switch to lookup ocamlmerlin binary
	;; (setq merlin-command 'opam)))

    ;; :hook (tuareg-mode-local-vars . (lambda () (when (executable-find "ocamlmerlin") (merlin-mode))))
    ;; )

#+end_src

** Custom keybindings
*** non leader key bound custom keymaps
#+begin_src emacs-lisp

  (evil-global-set-key 'motion (kbd "C-f") #'consult-line)
  (evil-global-set-key 'motion (kbd "C-s") #'save-buffer)
  (keymap-set global-map "C-M-k" #'scroll-other-window)
  (keymap-set global-map "C-M-j" #'scroll-other-window-down)

  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
  (setq scroll-step 1) ;; keyboard scroll one line at a time
  (evil-global-set-key 'normal (kbd "K") #'scroll-down-line)
  (evil-global-set-key 'normal (kbd "J") #'scroll-up-line)
  (evil-global-set-key 'visual (kbd "J") #'evil-join)

#+end_src
*** toggle keymap
#+begin_src emacs-lisp

  (defun my/open-vterm-in-split-window ()
    "Open vterm in a new window split horizontally at the bottom. Will try to be a buffer specific terminal. will close window if vterm is already open"
    (interactive)
    (split-window-below)
    (other-window 1)
    (if (derived-mode-p 'vterm-mode)
	(delete-window)
      (projectile-run-vterm)))

  (defvar-keymap my/toggle-keymap)
  (which-key-add-keymap-based-replacements my/toggle-keymap
    "t" '("theme" . consult-theme)
    "s" '("text scale" . hydra-text-scale/body)
    "d" '("diff" . ediff)
    "t" '("vterm" . my/open-vterm-in-split-window))

#+end_src
*** insert keymap
#+begin_src emacs-lisp

  (defvar-keymap my/insert-keymap)
  (which-key-add-keymap-based-replacements my/insert-keymap
    "s" '("org source block" . org-insert-structure-template))

#+end_src
*** default leader keymap
*** edit keymap
#+begin_src emacs-lisp

  (defvar-keymap my/edit-keymap)
  (which-key-add-keymap-based-replacements my/edit-keymap
    "t" '("transpose words" . transpose-words))

#+end_src
*** error keymap
#+begin_src emacs-lisp

  (defvar-keymap my/error-keymap)
  (which-key-add-keymap-based-replacements my/error-keymap
    "/" '("search all" . consult-flymake)
    "c" '("compile error" . consult-compile-error))

#+end_src
*** rings and regs keymap
#+begin_src emacs-lisp
  
    (defvar-keymap my/rings-and-regs-keymap)
    (which-key-add-keymap-based-replacements my/rings-and-regs-keymap
      "k" '("kill ring" . consult-yank-from-kill-ring)
      "j" '("jump list" . evil-collection-consult-jump-list)
      "s" '("reg store" . consult-register-store)
      "r" '("registers" . consult-register)
      "m" '("macro" . consult-register)
      )

#+end_src
*** buffer keymap
#+begin_src emacs-lisp

  (defvar-keymap my/buffer-keymap)
  (which-key-add-keymap-based-replacements my/buffer-keymap
    "p" '("project buffer" . consult-project-buffer)
    "b" '("switch buffer" . switch-to-buffer)
    "k" '("kill buffer and window" . kill-buffer-and-window)
    "/" '("find in buffers" . consult-line-multi)
    "I" '("imenu" . consult-imenu-multi))

#+end_src
*** window keymap
In the future the hydra should have keys that are more evil mode like and depend on where the window is for left and right
#+begin_src emacs-lisp

  (defhydra my/window-resize-hydra (:hint nil)
    ""
    ("<left>" shrink-window-horizontally "-narrower-")
    ("<right>" enlarge-window-horizontally "-wider-")
    ("<down>" shrink-window "|shorter|")
    ("<up>" enlarge-window "|longer|")
    ("=" balance-windows "equal")
    ("q"  nil))

  (defvar-keymap my/window-keymap)
  (which-key-add-keymap-based-replacements my/window-keymap
    "k" '("up" . evil-window-up)
    "j" '("down" . evil-window-down)
    "h" '("left" . evil-window-left)
    "l" '("right" . evil-window-right)
    "c" '("close" . evil-window-delete)
    "C" '("close others" . delete-other-windows)
    "v" '("vertical split" . split-window-vertically) 
    "s" '("sideways split" . split-window-horizontally)
    "L" '("send right" . evil-window-move-far-right)
    "H" '("send left" . evil-window-move-far-left)
    "K" '("send up" . evil-window-move-very-top)
    "J" '("send down" . evil-window-move-very-bottom)
    "m" '("minimize emacs" . suspend-frame)
    "s" '("text scale" . hydra-text-scale/body)
    "r" '("resize window" . my/window-resize-hydra/body))

#+end_src
*** project keymap
#+begin_src emacs-lisp

  (defvar-keymap my/project-keymap)
  (which-key-add-keymap-based-replacements my/project-keymap
    "/" '("all projects" . projectile-switch-project)
    "r" '("related file" . projectile-find-related-file))

#+end_src
*** file keymap
#+begin_src emacs-lisp

  (defun my/personal-config-dir ()
    "This function will get the directory that the user's init file is in"
    (interactive)
    (if-let (
	     (is-bound (boundp 'chemacs-profile))
	     (its-assoc (assoc 'user-emacs-directory chemacs-profile))
	     )
	(cdr its-assoc)
      (file-name-directory user-init-file)
      )
    )

  (defun my/open-personal-config-dir ()
    "This function will open the directory of the user's init file"
    (interactive)
    (let ((default-directory (concat (my/personal-config-dir) "/")))
      (call-interactively 'find-file)))

  (defvar-keymap my/file-keymap)
  (which-key-add-keymap-based-replacements my/file-keymap
    "p" '("personal config" . my/open-personal-config-dir)
    "r" '("recent files" . recentf-open-files)
    "/" '("search files" . projectile-find-file)
    "f" '("search uncached" . consult-fd))

#+end_src
*** code keymap
#+begin_src emacs-lisp

    (defvar-keymap my/code-keymap)
    (which-key-add-keymap-based-replacements my/code-keymap
      "d" '("definition" . xref-find-definitions)
      "r" '("references" . xref-find-references))

#+end_src
*** leader keymap

here‚Äôs a generalized rule for this scenario:

When you‚Äôre defining keybindings in Emacs, especially when dealing with complex conditions or multiple modes, it can be beneficial to manage these conditions at a higher level (like at the leader keymap level) rather than at the individual keybinding level. This approach can make your configuration cleaner and easier to manage.

Here‚Äôs a step-by-step explanation:

Define your keymaps: Create separate keymaps for each set of conditions. In your case, you might have one keymap for when LSP mode is on (lsp-on-keymap) and another for when LSP mode is off (lsp-off-keymap).
Bind your keys: Within each keymap, bind your keys to the appropriate commands without worrying about any conditions. The keybindings in each keymap are always active, but the keymap itself will only be active under certain conditions.
Use a conditional prefix key: Bind your prefix key (like ‚Äúc‚Äù in your leader keymap) to a menu-item form with a :filter property. The :filter function should return the appropriate keymap based on your conditions. In your case, it should return lsp-on-keymap when LSP mode is on and lsp-off-keymap when LSP mode is off.
With this approach, the conditions are managed at the prefix key level, and the individual keybindings don‚Äôt need to worry about any conditions. This can make your configuration more modular and easier to understand and maintain.

Here‚Äôs a code snippet that illustrates this concept:

(defvar lsp-on-keymap (make-sparse-keymap)
  "Keymap for when LSP mode is on.")
(define-key lsp-on-keymap (kbd "s") 'my-lsp-command)

(defvar lsp-off-keymap (make-sparse-keymap)
  "Keymap for when LSP mode is off.")
(define-key lsp-off-keymap (kbd "t") 'my-non-lsp-command)

(define-key leader-keymap (kbd "c")
  `(menu-item "" nil :filter ,(lambda (cmd) (if (lsp-mode) lsp-on-keymap lsp-off-keymap))))

In this code, ‚Äúc‚Äù in the leader keymap is bound to either lsp-on-keymap or lsp-off-keymap, depending on whether LSP mode is on or off. The individual keybindings in these keymaps don‚Äôt need to worry about LSP mode; they‚Äôre always active, but their keymap is only active under the right conditions. üòä
#+begin_src emacs-lisp

  ;; Leader keybindings
  ;; (defvar-keymap my/leader-keymap)
  ;; (which-key-add-keymap-based-replacements my/leader-keymap
  ;;   "." '("find file" . find-file)
  ;;   "/" '("fuzzy search" . consult-ripgrep)
  ;;   "g" '("git" . magit)
  ;;   ":" '("mode only command" . consult-mode-command)
  ;;   "Q" '("quit emacs" . save-buffers-kill-terminal)
  ;;   "f" `("File" . ,my/file-keymap)
  ;;   "p" `("Project" . ,my/project-keymap)
  ;;   "w" `("Window" . ,my/window-keymap)
  ;;   "b" `("Buffer" . ,my/buffer-keymap)
  ;;   "r" `("Rings and Regs" . ,my/rings-and-regs-keymap)
  ;;   "e" `("Edit" . ,my/edit-keymap)
  ;;   "!" `("Error" . ,my/error-keymap)
  ;;   "i" `("Insert" . ,my/insert-keymap)
  ;;   "t" `("Toggle" . ,my/toggle-keymap)
  ;;   "c" `("Code" . ,my/code-keymap))

  ;; ;; (unbind-key "SPC" evil-motion-state-map)
  ;; (bind-key "SPC" my/leader-keymap evil-motion-state-map)
  ;; (set-transient-map my/leader-keymap)

  ;; (defvar-keymap my/test-keymap)
  ;; (which-key-add-keymap-based-replacements my/test-keymap
  ;;   "." '("find file" . find-file))

  ;; (defun my/test-prefix-command ()
  ;;   "Choose a keymap to use as a prefix."
  ;;   (interactive)
  ;;   (set-transient-map my/test-keymap))

  ;; (unbind-key "C-m" evil-motion-state-map)
  ;; (bind-key "C-m" #'my/test-prefix-command evil-motion-state-map)

  ;; (defun my-command ()
  ;;   "Save the buffer."
  ;;   (interactive)
  ;;   (save-buffer))


  ;; (defvar my/modified-test-keymap (make-sparse-keymap)
  ;;   "Keymap for modified buffer.")
  ;; (define-key my/modified-test-keymap (kbd "s")
  ;; 	    (lambda () (interactive) (message "modified")))

  ;; (defvar my/unmodified-test-keymap (make-sparse-keymap)
  ;;   "Keymap for unmodified buffer.")
  ;; (define-key my/unmodified-test-keymap (kbd "t")
  ;; 	    (lambda () (interactive) (message "unmodified")))

  ;; ;;we effectively get to dynamically decide what is in this keymap by activating a keymap programatically once this keymap is active
  ;; (define-key global-map (kbd "C-m")
  ;; 	    `(menu-item "" nil :filter ,(lambda (cmd) (if (buffer-modified-p) my/modified-test-keymap my/unmodified-test-keymap))))

  ;; ;; (defvar-keymap my/overall-test-keymap
  ;;   `(menu-item "" nil :filter ,(lambda (cmd) (if (buffer-modified-p) my/modified-test-keymap my/unmodified-test-keymap)))
  ;;   (kbd "a")`(menu-item ""  (lambda () (interactive) (message "I don't care if the buffer is modified")))
  ;;   )

  ;; (define-key evil-motion-state-map (kbd "C-n") my/overall-test-keymap) 
  ;; (defvar-keymap my/test-keymap)
  ;;   (bind-key "C-m" my/test-keymap evil-motion-state-map)
  ;;   (define-key my/modified-test-keymap (kbd "s")
  ;; 	      `(menu-item "" my-command :filter ,(lambda (cmd) (if (buffer-modified-p) my/leader-keymap)) :visible ,(lambda (cmd) (if (buffer-modified-p) my/leader-keymap))))
  ;;   ;; can use this to dynamically pick sub keymaps
  ;;   (define-key my/modified-test-keymap (kbd "s")
  ;; 	      `(menu-item "" my-command :filter ,(lambda (cmd) (if (buffer-modified-p) my/leader-keymap)) :visible ,(lambda (cmd) (if (buffer-modified-p) my/leader-keymap))))

  ;;   (define-key my/unmodified-test-keymap (kbd "t")
  ;; 	      `(menu-item "" my-second-command :filter ,(lambda (cmd) (if (not (buffer-modified-p)) my/leader-keymap)) :visible ,(lambda (cmd) (if (not (buffer-modified-p)) my/leader-keymap))
  ;; ))

#+end_src
*** custom lsp keymap
#+begin_src emacs-lisp

  (defun my/create-lsp-code-map ()
    (let ((my/lsp-code-keymap (define-keymap :parent my/code-keymap)))
      (when (bound-and-true-p lsp-mode)
	;; things that don't need additional conditions
	(which-key-add-keymap-based-replacements my/lsp-code-keymap
	  "p" '("describe at point" . lsp-describe-thing-at-point)
	  "a" '("code action" . lsp-execute-code-action)
	  "=" '("format buffer" . lsp-format-buffer)
	  "h" '("highlight" . lsp-document-highlight))

	(when (lsp-feature? "textDocument/definition")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "d" '("definition" . lsp-find-definition)))

	(when (lsp-feature? "textDocument/references")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "r" '("references" . lsp-find-references)))

	(when (lsp-feature? "textDocument/implementation")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "i" '("implementation" . lsp-find-implementation)))

	(when (lsp-feature? "textDocument/declaration")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "!" '("declaration" . lsp-find-declaration)))

	(when (lsp-feature? "textDocument/typeDefinition")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "t" '("type definition" . lsp-find-type-definition)))

	(when (or (lsp-can-execute-command? "java.navigate.resolveTypeHierarchy")
		  (and (functionp 'lsp-treemacs-type-hierarchy)
		       (lsp-feature? "textDocument/typeHierarchy")))
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "T" '("type hierarchy" . lsp-treemacs-type-hierarchy)))

	(when (and (functionp 'lsp-treemacs-call-hierarchy)
		   (lsp-feature? "textDocument/callHierarchy"))
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "c" '("call hierarchy" . lsp-treemacs-call-hierarchy)))

	(when (lsp-feature? "textDocument/rename")
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap
	    "R" '("rename" . lsp-rename)))

	;; Session keybindings
	(let ((my/session-lsp-code-keymap (define-keymap)))
	  (which-key-add-keymap-based-replacements my/session-lsp-code-keymap
	    "l" '("logs" . lsp-workspace-logs-show)
	    "d" '("describe session" . lsp-describe-session)
	    "s" '("shutdown" . lsp-shutdown-workspace))
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap "S" `("Lsp Session" . ,my/session-lsp-code-keymap)))

	;; Workspace folders keybindings
	(let ((my/workspace-folders-lsp-code-keymap (define-keymap)))
	  (which-key-add-keymap-based-replacements my/workspace-folders-lsp-code-keymap
	    "a" '("add workspace folder" . lsp-workspace-folders-add)
	    "r" '("remove workspace folder" . lsp-workspace-folders-remove)
	    "o" '("open workspace folder" . lsp-workspace-folders-open))
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap "F" `("Lsp Workspace Folders" . ,my/workspace-folders-lsp-code-keymap)))

	;; Toggle lsp features keybindings
	(let ((my/toggle-lsp-features-code-keymap (define-keymap)))
	  (which-key-add-keymap-based-replacements my/toggle-lsp-features-code-keymap
	    "l" '("code lens" . lsp-lens-mode)
	    "h" '("breadcrumb" . lsp-headerline-breadcrumb-mode)
	    "a" '("modeline code actions" . lsp-modeline-code-actions-mode)
	    "d" '("modeline diagnostics" . lsp-modeline-diagnostics-mode))
	  (which-key-add-keymap-based-replacements my/lsp-code-keymap "T" `("Lsp Toggle Features" . ,my/toggle-lsp-features-code-keymap)))

	my/lsp-code-keymap)))

    (add-hook 'lsp-after-open-hook
	      (lambda ()
		(evil-local-set-key 'motion (kbd "SPC c") (my/create-lsp-code-map))))


#+end_src

*** EPIC EXAMPLE OF DYNAMIC KEYMAPS
#+begin_src emacs-lisp

  ;; (defvar-keymap my/modified-buffer-keymap
  ;;   (kbd "s") (lambda () (interactive) (message "this buffer is modified")))

  ;; (defvar-keymap my/unmodified-buffer-keymap
  ;;   (kbd "t") (lambda () (interactive) (message "this buffer is unmodified")))

  ;; ;; original filter that has which-key issue
  ;; (defun my/filter-function (cmd)
  ;;   (if (buffer-modified-p)
  ;;       (progn
  ;; 	(message "using modified keymap")
  ;; 	my/modified-buffer-keymap)
  ;;     (message "using unmodified keymap")
  ;;     my/unmodified-buffer-keymap))


  ;; epic solution to which-key-problems
  ;; (defun my/filter-function (_cmd)
  ;;   (cl-destructuring-bind (name map)
  ;;       (if (buffer-modified-p)
  ;; 	  (list "group:modified" my/modified-buffer-keymap)
  ;; 	(list "group:unmodified" my/unmodified-buffer-keymap))
  ;;     ;; we don't actually need to define-prefix, but it is more explicit that is what we are doing.
  ;;     ;; we make-symbol because we want to make a symbol that isn't in the obarray. We don't need to
  ;;     ;; refer to it by name because we are passing it around. We create a new unique command despite others that
  ;;     ;; may already exist in the global scope. defvar would reuse the old command if a variable with that name existed. No interference
  ;;     (let ((cmd (define-prefix-command (make-symbol name))))
  ;;       (fset cmd map)
  ;;       cmd)))


  ;; less runtime computation solution
  ;; (defvar my/modified-buffer-prefix-command
  ;;   (let ((cmd (define-prefix-command (make-symbol "group:modified")))
  ;; 	(map (make-sparse-keymap)))
  ;;     (define-key map (kbd "s") (lambda () (interactive) (message "this buffer is modified")))
  ;;     (fset cmd map)
  ;;     cmd))

  ;; ;; So in the value slot of the variable created by defvar, we have a pointer to the uninterned symbol.
  ;; The function slot of the uninterned symbol we have a keymap, making the uninterned symbol a prefix command.
  ;; when we use the variable name as a variable it is resolved to the uninterned symbol, and thus the prefix command.
  ;; each symbol has a name property so we can find that there. We don't actually want to reserve the name group:modified globally.

  ;; (defvar my/unmodified-buffer-prefix-command
  ;;   (let ((cmd (define-prefix-command (make-symbol "group:unmodified")))
  ;; 	  (map (make-sparse-keymap)))
  ;;     (define-key map (kbd "t") (lambda () (interactive) (message "this buffer is unmodified")))
  ;;     (fset cmd map)
  ;;     cmd))

  ;; alternative way of doing it. But it is best to avoid having group:modified in the global scope I think.
  ;; (defvar group:modified (make-sparse-keymap))
  ;; (define-prefix-command 'group:modified)
  ;; (define-key group:modified (kbd "t") (lambda () (interactive) (message "this buffer is unmodified")))


  ;; (defun my/filter-function (_cmd)
  ;;   (if (buffer-modified-p)
  ;; 	my/modified-buffer-prefix-command
  ;;     my/unmodified-buffer-prefix-command))

  ;; ;;we effectively get to dynamically decide what is in this keymap by activating a keymap
  ;; programatically once this keymap is active
  ;; (define-key global-map (kbd "C-c p")
  ;; 	    '(menu-item "" nil :filter my/filter-function))


  ;; (which-key-add-keymap-based-replacements global-map
  ;; 	"C-c p" '("buffer echoes" . (menu-item "" nil :filter my/filter-function)))
  ;; (defvar-keymap my/buffer-prefix-keymap
  ;; 	    (kbd "m") '(menu-item "" nil :filter my/filter-function))

  ;; (define-key global-map (kbd "C-c a") my/buffer-prefix-keymap)


#+end_src
**** Custom local keymaps
***** major mode to local keymap alist and associated filter function
#+begin_src emacs-lisp

  (defvar-keymap my/default-local-leader-keymap)
  (which-key-add-keymap-based-replacements my/default-local-leader-keymap
    "m" `("I am empty" . ,(lambda () (interactive) (message "nothing here"))))

  (defvar my/major-mode-local-leader-keymap-alist (list))

  (defun my/filter-local-leader-keymap (_cmd)
    "return the appropriate local leader keymap"
    ;; (message "local leader filtering! %s" major-mode)
    (alist-get major-mode my/major-mode-local-leader-keymap-alist my/default-local-leader-keymap))

#+end_src
***** vterm
#+begin_src emacs-lisp

  (defvar-keymap my/vterm-local-leader-keymap)
  (which-key-add-keymap-based-replacements my/vterm-local-leader-keymap
    "s" '("send stop" . vterm-send-stop))

  (push (cons 'vterm-mode my/vterm-local-leader-keymap) my/major-mode-local-leader-keymap-alist)

#+end_src
***** tuareg
#+begin_src emacs-lisp

  (defvar-keymap my/tuareg-local-leader-keymap)
  (which-key-add-keymap-based-replacements my/tuareg-local-leader-keymap
    "o" '("other ml/mli" . tuareg-find-alternate-file))

  (push (cons 'tuareg-mode my/tuareg-local-leader-keymap) my/major-mode-local-leader-keymap-alist)

#+end_src
*** custom leader minor mode
default created keymap is `my/leader-key-mode-map`
#+begin_src emacs-lisp

  ;; alist of lsp roots containing alists of (major-mode . keymap), overall structure is (some-root . ((major-mode . keymap) ...))
  (defvar my/leader-key-mode--active-lsp-root-alist nil)

  (defmacro my/assoc-default-insert (alist key default-value)
    "Ensure that ALIST has an entry for KEY. If not, add (KEY . DEFAULT-VALUE) to ALIST. Always return the (KEY . value) entry"
    `(or (assoc ,key ,alist)
	 (let ((new-entry (cons ,key ,default-value)))
	   (push new-entry ,alist)
	   new-entry)))

  ;; (macroexpand '(my/assoc-default-insert my/leader-key-mode--active-lsp-root-alist lsp-root (cons major-mode (list nil))))

  ;; another way to do this would just be to make a buffer local keymap that gets served by the menu, but then
  ;; we would make a duplicate keymap for every pyhton buffer in a pyton project which seems wasteful
  (defun my/leader-key-mode--get-keymap-for-lsp-project-and-major-mode ()
    "Get the keymap that is associated with this lsp session's root and major mode. If lsp-mode is not enabled in this buffer, return the default code keymap"
    (let* ((lsp-root (lsp-workspace-root))
	   (major-mode-keymap-alist
	    (my/assoc-default-insert my/leader-key-mode--active-lsp-root-alist lsp-root (cons major-mode nil)))
	   (keymap
	    (cdr (my/assoc-default-insert (cdr major-mode-keymap-alist) major-mode (my/create-lsp-code-map)))))
      ;; (message "lsp root is %s" lsp-root)
      ;; (message "major-mode-keymap-alist:")
      ;; (prin1 major-mode-keymap-alist)
      ;; (message "keymap:")
      ;; (prin1 keymap)
      keymap))

  (defun my/leader-key-mode--filter-code-keymap (_cmd)
    "return the default code keymap if lsp-mode is off in this buffer, otherwise return the lsp code keymap. _CMD is unused."
    ;; (message "filtering!")
    (let* ((keymap
	    (if lsp-mode
		(progn
		  ;; (message "going to use lsp code keymap")
		  (my/leader-key-mode--get-keymap-for-lsp-project-and-major-mode))
	      ;; (message "Going to use regular code keymap")
	      my/code-keymap))
	   (pref-cmd (define-prefix-command (make-symbol "group:Code"))))
      (fset pref-cmd keymap)
      pref-cmd))


  ;; (defvar my/code-keymap-group-pointer
  ;;   (let ((cmd (define-prefix-command (make-symbol "group:Code"))))
  ;;     (fset cmd my/code-keymap)
  ;;     cmd))


  ;; (defun my/filter-function (_cmd)
  ;;   (cl-destructuring-bind (name map)
  ;; 	(if (buffer-modified-p)
  ;; 	    (list "group:modified" my/modified-buffer-keymap)
  ;; 	  (list "group:unmodified" my/unmodified-buffer-keymap))
  ;;     (let ((cmd (define-prefix-command (make-symbol name))))
  ;; 	(fset cmd map)
  ;; 	cmd)))

  (defvar-keymap my/leader-keymap
    (kbd "c") '(menu-item "code" nil :filter my/leader-key-mode--filter-code-keymap))

  (which-key-add-keymap-based-replacements my/leader-keymap
    "." '("find file" . find-file)
    "/" '("fuzzy search" . consult-ripgrep)
    "g" '("git" . magit)
    ":" '("mode only command" . consult-mode-command)
    "Q" '("quit emacs" . save-buffers-kill-terminal)
    "f" `("File" . ,my/file-keymap)
    "p" `("Project" . ,my/project-keymap)
    "w" `("Window" . ,my/window-keymap)
    "b" `("Buffer" . ,my/buffer-keymap)
    "r" `("Rings and Regs" . ,my/rings-and-regs-keymap)
    "e" `("Edit" . ,my/edit-keymap)
    "!" `("Error" . ,my/error-keymap)
    "i" `("Insert" . ,my/insert-keymap)
    "t" `("Toggle" . ,my/toggle-keymap))


  (define-minor-mode my/leader-key-mode
    "Minor mode for my leader keybindings"
    :global t ;; not buffer local
    :init-value 1 ;; default should be on
    :keymap
    (let ((new-minor-mode-keymap (make-sparse-keymap)))
      (define-key new-minor-mode-keymap
		  (kbd "C-SPC") my/leader-keymap)
      new-minor-mode-keymap)
    :lighter "my-leader"
    :interactive t
    ;; other :keywords I define here will be just passed to defcustom along with the values I set them to
    ;; body code, will run when mode is toggled, can just check if it is on or off
    )

  (define-key evil-motion-state-map (kbd "SPC") nil)
  ;; using motion instead of normal here actually doesn't work
  (evil-define-minor-mode-key 'normal 'my/leader-key-mode
    (kbd "SPC") my/leader-keymap)

  (evil-define-minor-mode-key 'normal 'my/leader-key-mode
    (kbd "m") '(menu-item "local-leader" nil :filter my/filter-local-leader-keymap))

  ;; you can have buffer local keymaps, but you need to serve them from a menu's filter function
  ;; because binding to a keymap evualtes the variable.
  ;; (defvar-keymap my/test-keymap
  ;;   "a" (lambda () (interactive) (message "a")))

  ;; (make-local-variable 'my/test-keymap)

  ;; (add-hook 'lsp-mode-hook
  ;; 	  (lambda ()
  ;; 	    (define-key my/test-keymap
  ;; 			(kbd "b") (lambda ()
  ;; 				    (interactive) (message "b")))))


  ;; ;; (MESSAGE (propertize "Code" 'face 'which-key-group-description-face))

  ;; (setq which-key-replacement-alist
  ;;     `((("Code" . nil) . (,(propertize "Code" 'face 'which-key-group-description-face) . nil))
  ;;       ,@which-key-replacement-alist))


#+end_src
** Bookmarks
*** save bookmarks on creation
By default they are only saved when you exit emacs which could prevent them from being saved if emacs crashes
#+begin_src emacs-lisp

 (setq bookmark-save-flag 1) 

#+end_src
** auto close brackets
#+begin_src emacs-lisp

  (electric-pair-mode t)
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)

#+end_src

** backup each save
TODO: may want to clear old ones because this package doesn't do that. It is simple code so can just copy it and change stuff. 
#+begin_src emacs-lisp

  (use-package backup-each-save
    :custom
    (backup-each-save-mirror-location ~/backups)
    (backup-each-save-remote-files t)
    (backup-each-save-size-limit 10000)
    :hook
    (after-save . backup-each-save))

#+end_src
** dired
drag files is really cool you can choose whether you copy, move, or link depending if you hold shift meta or ctrl
#+begin_src emacs-lisp

  (setq dired-mouse-drag-files t)

#+end_src
** dashboard
#+begin_src emacs-lisp

  (use-package dashboard
    :init
    (setq dashboard-display-icons-p t)
    (setq dashboard-icon-type 'nerd-icons)
    (setq dashboard-center-content t)
    (setq dashboard-vertically-center-content t)
    (setq dashboard-show-shortcuts nil)
    (setq dashboard-items '(
			    (bookmarks . 5)
			    (projects  . 5)
			    (agenda    . 5)))

    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)

    (setq dashboard-startupify-list '(dashboard-insert-banner
				      dashboard-insert-newline
				      dashboard-insert-navigator
				      dashboard-insert-newline
				      dashboard-insert-init-info
				      dashboard-insert-items))
    (setq dashboard-startup-banner
	  (expand-file-name "emacs-splash.svg"
			    (my/personal-config-dir)))
    (setq dashboard-projects-backend 'projectile)
    :config
    (setq initial-buffer-choice (lambda () (get-buffer-create dashboard-buffer-name)))
    (dashboard-setup-startup-hook))


#+end_src
** built in emacs non setup
Another way to go is CUA mode that gives you the expected C-c and friends behavior of other programs.
It also implicitly has the delete selection mode on.
#+begin_src emacs-lisp

  (pixel-scroll-precision-mode 1) ;; nicer scrolling with mouse wheel
  (delete-selection-mode 1) ;; pasting when region is highlighted replaces it
  (add-to-list 'default-frame-alist '(fullscreen . maximized)) ;;full screen on startup

#+end_src
